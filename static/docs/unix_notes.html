<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <title>linux_notes</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="/css/normalize.css" type="text/css">
    <link rel="stylesheet" href="/css/sakura.css" type="text/css">
    <link rel="stylesheet" href="/css/style.css" type="text/css">
  </head>
  <body>
  <nav>
    <ul>
      <li><a href="/">home</a></li>
      <li><a href="/docs/">docs</a></li>
      <li><a href="http://git.laydros.net">repo</a></li>
      <li><a href="/about.html">about</a></li>
    </ul>
  </nav>
    <br />
<main>
<h1>random unix/*nix notes</h1>

<p>There is a lot of stuff I end up wanting to refer to later. I&#8217;m putting some here.</p>

<h5><a href="/docs/firefox.html">Firefox stuff</a></h5>
<h5><a href="/docs/thinkpad.html">Thinkpad stuff</a></h5>
<h5><a href="/docs/vi.html">vi stuff</a></h5>

<h3 id="setcapsasctrl">Set caps as ctrl</h3>

<p>Doing it this way seems to work across the console and X:</p>

Edit <code>/etc/default/keyboard</code> and set:
<pre><code>XKBOPTIONS=ctrl:nocaps</code></pre>
If you already have XKBOPTIONS set, append <code>ctrl:nocaps</code> to its existing value using a comma for separator, e.g.:
<pre><code>XKBOPTIONS=&quot;terminate:ctrl_alt_bksp,ctrl:nocaps&quot;</code></pre>
Should be effective after next reboot or issuing the <code>setupcon</code> command.

<h2>Debian</h2>
<h5>Enable auto upgrades</h5>
Install unattended-upgrades package:
<code><pre>sudo apt install unattended-upgrades</code></pre>
To activate unattened-upgrades, you need the apt configuration stub <code>/etc/apt/apt.conf.d/20auto-upgrades</code> has
the correct lines. This can be done automatically by running:
<code><pre>sudo dpkg-reconfigure -plow unattened-upgrades</code></pre>
Or to run it non-interactively:
<code><pre>echo unattended-upgrades unattended-upgrades/enable_auto_updates boolean true | debconf-set-selections
dpkg-reconfigure -f noninteractive unattended-upgrades</code></pre>


<h3>Keychron F-Keys under Linux</h3>
<ul>
<li>Problem 1: In wired mode the fn keys don't work correctly  
  <pre>Fix: Set <code>/sys/module/hid_apple/parameters/fnmode</code> to 0 or 2</pre>
</li>
<li>Problem 2: In bluetooth mode none of the keys work correctly  
  <pre>Fix: Set <code>/sys/module/hid_apple/parameters/fnmode</code> to 0</pre>
</li>
<li>
Command to use: <pre><code>echo 0 | sudo tee /sys/modules/hid_apple/parameters/fnmode</code></pre>
</li>
</ul>



<h5>Making <code>/sys/module/hid_apple/parameters/fnmode</code> changes persistent</h5> 
<ul> 
<li>Create a file <code>/etc/modprobe.d/hid_apple.conf</code> with content
<code>options hid_apple fnmode=0</code></li>
<li>After this run the following command:
<pre>Ubuntu: <code>sudo update-initramfs -u</code>
Arch: <code>sudo mkinitcpio -P linux</code></pre>
</li>
</ul>

<h3>Merge or split pdf files</h3>
<p>Install <code>poppler-tools</code> from package manager.</p>

To concatenate first.pdf and second.pdf into full.pdf
<pre><code>pdfunite first.pdf second.pdf full.pdf</code></pre>

To split a full.pdf into a pdf for each page
<pre><code>pdfseparate full.pdf page-%d.pdf</pre></code>

<h3>My tmux setup</h3>
<p>Allows <code>mosh host -- tmux a</code>. Uses C-z</p>
<pre><code>curl https://laydros.net/docs/conf/tmux.conf -o ~/.tmux.conf</code></pre>

<h3 id="macos">macOS</h3>

<ul>
<li>os x - pipe to <code>pbcopy</code> for clipboard</li>
<li>os x - sharing:<br />
create share points for afp, ftp and smb services.<br />
A new utility on OS X Mountain Lion which lets you quickly share directories from the command line, e.g.:<br />
<code>sudo sharing -a /Users/you/yourshare</code></li>
</ul>

<h3 id="rando">rando</h3>
<pre><code># list directory sizes
$ du -sh *

# count all occurrences of a string in a directory
$ grep -roh lorem . | wc -w

# watch a remote log
$ ssh user@server &quot;tail -f /var/log/apache2/error.log&quot;

# Create directories a through z inside log/users/, creating any 
parent directories that don&apos;t exist yet too.
$ mkdir -p log/users/{a..z}

# brace expansion example
$ mkdir -p drupal/sites/all/modules/{contrib,custom,patched,features}

# launch program and ditch so term can be closed
$ &lt;command&gt; &amp; disown

# df with posix mode, don&apos;t make 80 columns wide
$ df -hP

cat &lt;file&gt; | tee output.txt | grep &lt;term&gt;

- grep -r -i somethingtosearchfor ./
- pgrep - search processes
- ngrep - monitor network activity</code></pre>

<h3>Audio Conversion</h3>
<h5>wav to flac</h5>
Create a flac with the same name
<pre><code>$ flac inputfile.wav</code></pre>
Create an MP3
<pre><code>$ ffmpeg -i inputfile.wav -acodec mp3 outputfile.mp3</code></pre>
Set bitrate with -ab
<pre><code>$ ffmpeg -i inputfile.wav -acodec mp3 -ab 64k outputfile.mp3</code></pre>

<h3 id="splittingfiles">splitting files</h3>
Split a file called largefile into 1 gigabyte pieces called split-xaa, 
split-xab, split-xac ...
<pre><code>$ split -b 1G verylargefile split</pre></code>
Join the splits back together
<pre><code>$ cat split-xaa split-xab split-xac &gt; rejoinedlargefile</pre></code>

Join the files together with brace expansion. Be mindful of filenames and order.

<pre><code>$ cat split-xa{a,b,c} &gt; rejoinedlargefile</code></pre>

<h3>Disable SSH access except for key</h3>
Update /etc/ssh/sshd_config with the following:
<pre><code>PermitRootLogin no
PasswordAuthentication no
ChallengeResponseAuthentication no
UsePAM no
</code></pre>

restart the service:

<pre><code># debian, arch, other systemd
systemctl restart sshd

# OpenBSD
rcctl restart sshd
</pre></code>

<h3>OpenBSD</h3>
<h5>Caps Lock as Control</h5>
<code><pre># wsconsctl keyboard.map+="keysym Caps_Lock = Control_L"
</code></pre>

<p>To make this run at boot, add <code>keyboard.map+="keysym Caps_Lock = Control_L"</code> to /etc/wsconsctl.conf.</p>

Still need to add the following to .xsession when you are 
using <a href="https://www.xenocara.org/">xenocara</a>
<pre><code>setxkbmap -option 'ctrl:nocaps'</code></pre>

<h3 id="fio">fio - flexible io tester</h3>
fio is a tool for testing disk speed. It is probably easiest to use with the included job files in the <a href="https://github.com/axboe/fio/tree/master/examples">examples</a> directory. You can also use <code>--showcmd=<jobfile></code> to extract the commands from a job file. However here are a few sample commands:

<pre><code># random write test
sudo fio --name=randwrite --ioengine=libaio --iodepth=1 --rw=randwrite --bs=4k --direct=0 --size=512M --numjobs=2 --runtime=240 --group_reporting

# random read test
sudo fio --name=randread --ioengine=libaio --iodepth=16 --rw=randread --bs=4k --direct=0 --size=512M --numjobs=4 --runtime=240 --group_reporting

# read write performance test
sudo fio --randrepeat=1 --ioengine=libaio --direct=1 --gtod_reduce=1 --name=test --filename=random_read_write.fio --bs=4k --iodepth=64 --size=4G --readwrite=randrw --rwmixread=75
</code></pre>

The <code>ioengine</code> setting must be changed for different systems. The <code>libaio</code> engine is specific to Linux. On macOS you may want to use <code>psync</code> or <code>posixaio</code>.

Also consider hdparm, Bonnie++, and using dd to create a file with <code>if=/dev/zero</code>.

<h3 id="rsync">rsync</h3>
<pre><code>/usr/local/bin/rsync --info=progress2 --modify-window=1 -rltvh --no-perms /var/run/importcopy/tmpdir/dev/da3p1/ /mnt/storpool/share</code></pre>

<p><code>rsync -essh -rtpvz</code> rocks. Really, there’s nothing more to say. Learn it. Use it. Love it. Here’s a good rsync anecdote: in my last job, I worked on a project that was doing daily (and sometimes more-than-once-per-day) builds of a 100 MB installer. Near the end of the release cycle, we were putting each daily build on a private web server for the client to download and test. Uploading the entire build took over a hour on my capped DSL line. It turns out that the fastest way to do this is to ssh into the server, duplicate yesterday’s build to a file with today’s date, then rsync today’s build up to the server. rsync magically figures out which parts of the installer have changed (usually not more than a few KB) and synchronizes the build in under a minute. I have no idea how it does that. I read once that it was somebody’s PhD project. Thank God for smart people.</p>

<h3>Gnome taskbar icon duplication</h3>
If Gnome doesn't recognize an application, it will spawn a new icon for every window instead of collapsing them into the app icon.

First find the window class by running <pre><code>xprop WM_CLASS</code></pre>
This creates a crosshair, click on the window and it will list a window class
In the .desktop file for the program add <pre>StartupWMClass=st-256-color</pre> replacing 'st-256-color' with the class you got from xprop.

<h2>git</h2>
<h5>Updating a fork from upstream</h5>
<b>From: <a href="https://stackoverflow.com/questions/7244321/how-do-i-update-a-github-forked-repository">SO</a></b><br />
In your local clone of your forked repository, you can add the original GitHub repository as a "remote".  ("Remotes" are like nicknames for the URLs of repositories - `origin` is one, for example.)  Then you can fetch all the branches from that upstream repository, and rebase your work to continue working on the upstream version.  In terms of commands that might look like:

<pre><code>
    # Add the remote, call it "upstream":
    
    git remote add upstream https://github.com/whoever/whatever.git
    
    # Fetch all the branches of that remote into remote-tracking branches,
    # such as upstream/master:
    
    git fetch upstream

    # Make sure that you're on your master branch:
    
    git checkout master
    
    # Rewrite your master branch so that any commits of yours that
    # aren't already in upstream/master are replayed on top of that
    # other branch:
    
    git rebase upstream/master
</code></pre>

If you don't want to rewrite the history of your master branch, (for example because other people may have cloned it) then you should replace the last command with `git merge upstream/master`.  However, for making further pull requests that are as clean as possible, it's probably better to rebase.

----

If you've rebased your branch onto `upstream/master` you may need to force the push in order to push it to your own forked repository on GitHub.  You'd do that with:

<pre><code>$ git push -f origin master</code></pre>
You only need to use the <code>-f</code> the first time after you've rebased.

<h4>Shallow clone for large repo</h4>
With the depth parameter as:

<pre><code>$ git clone --depth=1 https://github.com/mozilla/gecko-dev</pre></code>

Once you have shallow clone, you can deepen it. To fetch 100 commits use:

<pre><code>$ git fetch --depth=100</pre></code>

or if you want to get all commits then simply use:

<pre><code>$ git fetch --unshallow</pre></code>

and that would fetch all the commits and make your repo similar to what you do in the initial place like using git clone simply.

<h2>Emacs</h2>
<h4>Directly launching emacs to a particular mode</h4>
Use the command
<pre><code>$ emacsclient -c -a ' ' --eval '(ibuffer)'</pre></code>
replacing "ibuffer" with something like "mu4e," "elfeed", "eshell," or "dired nil"

    <h3>KVM and virsh</h3>
      <h4>Convert ova to use with KVM</h4>
      from <a href="https://wiki.hackzine.org/sysadmin/kvm-import-ova.html">here</a>
      <code>
      # untar the archive 
      % tar xvf some-vm.ova
      
      # check that qemu-img supports required image types
      % qemu-img -h | tail -n1

      # convert image to qcow2
      % qemu-img convert -O qcow2 some-vm-disk1.vmdk some-vm.qcow2
      </code>
      <p>Use the new file as the disk for your VM. Check some-vm.ovf for information on settings for the VM.</p>
    </main>

  </body>
</html>
